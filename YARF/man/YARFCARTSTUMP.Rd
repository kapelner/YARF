% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/YARFCART.R
\name{YARFCARTSTUMP}
\alias{YARFCARTSTUMP}
\title{Create a single tree stump}
\usage{
YARFCARTSTUMP(
  X = NULL,
  y = NULL,
  Xy = NULL,
  Xother = NULL,
  allow_missingness_in_y = FALSE,
  bootstrap_indices = NULL,
  other_indices = NULL,
  mtry = NULL,
  mtry_script = NULL,
  split_vals_script = NULL,
  make_node_to_leaf_script = NULL,
  cost_single_node_calc_script = NULL,
  cost_both_children_calc_script = NULL,
  node_assign_script = NULL,
  after_node_birth_function_script = NULL,
  shared_scripts = NULL,
  use_missing_data = TRUE,
  replace_missing_data_with_x_j_bar = FALSE,
  serialize = FALSE,
  seed = NULL,
  calculate_oob_error = TRUE,
  oob_cost_calculation_script = NULL,
  verbose = TRUE,
  debug_log = FALSE
)
}
\arguments{
\item{X}{The data frame of training data}

\item{y}{The vector of training responses which is either numeric (for regression 
or factor (for classification).}

\item{Xy}{The data frame of training data where the last column is responses}

\item{Xother}{Other data that is used in the training but the RF doesn't split on it}

\item{allow_missingness_in_y}{If \code{TRUE}, missingness in the response variable, \code{y}, is allowed. If the missings are not
handled (somehow) in the custom functions, YARF will crash!! Default is \code{FALSE}.}

\item{bootstrap_indices}{A list with keys 1, 2, ..., num_trees where each value is the indices of the training data
you wish to use for each tree. The default is \code{NULL} indicating the default algorithm 
of sampling {1,...,n} with replacement (i.e. the non-parametric bootsrap default). Needless
to say indices specified here will not be part of the out-of-bag collection of indices.    You may
specify more than enough (i.e. more than \code{num_trees}) elements in this list. Only the first
\code{num_trees} will be used. No warning message will be displayed if you include too many. If 
this parameter is specified, there is no need to specify \code{n_max_per_tree}.}

\item{other_indices}{An optional list with keys 1,2,..., num_trees where each value is indices of the training data
you wish to use in some custom way for each tree using a custom function. If not custom function
is specified which makes use of this, it will be ignored. However, indices specified here will not be part of 
the out-of-bag collection of indices. If this is not your wish, the elements in the vectors
specified in this list's values should be a subset of those in the values of \code{bootstrap_indices}.
The default is \code{NULL} indicating you do not wish to specify any "other" data records.}

\item{mtry}{The number of variables tried at every split. The default is \code{NULL} which indicates
the out-of-box RF default which is floor(p / 3) for regression and floor(sqrt(p)) for
classification. If you want to use all possible features, set this parameter to "all".
If you want a custom function, leave this NULL and see next parameter.}

\item{mtry_script}{A custom javascript function which selects the variables to be greedily searched (see below)
                                            The default is \code{NULL} which employs the \code{mtry} argument. If you specify your function
                                            please randomize the order of the returned attributes to arbitrate ties.

                                              function tryVars(node)\{ //node is of type YARF.YARFNode

                                                ...

                                                return int_array //a subset of {0,...,p-1}, indices indicating the variables to perform the exhaustive search on

                                              \}}

\item{split_vals_script}{A custom javascript function which selects the split values to be greedily searched in feature j.
                                            The default is \code{NULL} which employs the midpoints of all sorted values.

                                              function tryVals(node, j)\{ //node is of type YARF.YARFNode and j is the feature number in {0,...,p-1}

                                                ...

                                                return double_array //a vector of split vals to greedily assess

                                              \}}

\item{make_node_to_leaf_script}{A custom javascript function to be used to calculate nodesize (see below).
                                            The default is \code{NULL} where nodesize will be calculated as a static constant (see the 
                                            \code{nodesize} argument).

                                              function makeNodeIntoLeaf(node)\{ //node is of type YARF.YARFNode

                                                ...

                                                return boolean //where true makes this node into a leaf

                                              \}}

\item{cost_single_node_calc_script}{A custom cost calculation for a potential node (when considering a split) in Javascript (see below). 
                                            The default is \code{NULL} which means the out-of-the-box default of sum of squared error relative
                                            to the sample average (if regression) and sum of entropy (if classification). You may find it 
                                            convenient to also made a node assignment here. If so, make sure you specify the node assignment
                                            function as a blank function (not \code{NULL}).

                                              function nodeCost(node)\{ //node is of type YARF.YARFNode

                                                ...

                                                return double //where a higher number indicates a higher cost

                                              \}}

\item{cost_both_children_calc_script}{A custom cost calculation in Javascript for an entire split considering both the putative left and right children
                                            nodes (see below). The default is \code{NULL} which means the out-of-the-box default for Random Forests which is
                                            sum of left and right nodes' costs for regression and average of left and right nodes' cost (relative
                                            to the number of observations in each node).

                                              function totalChildrenCost(leftNode, rightNode)\{ //both nodes are of type YARF.YARFNode

                                                ...

                                                return double //where a higher number indicates a higher cost

                                              \}}

\item{node_assign_script}{A custom node assignment function in Javascript (see below). This function is run after RF greedily finds the 
                                            "lowest cost" split. The default is \code{NULL} corresponding to the sample average of the node responses 
                                            in regression or the modal class during classification. 

                                              function assignYhatToNode(node)\{ //node is of type YARF.YARFNode

                                                ...

                                                return double //assigned as this node's predicted value ("y_hat")

                                              \}}

\item{after_node_birth_function_script}{A custom function in Javascript which is executed after a node is given birth to. The default is 
                                            \code{NULL} which implies nothing special is done, the Random Forest default. This is particularly
                                            useful to record extra information in the node (e.g. by writing a hash to the \code{other_info} 
                                            field in the node).

                                              function nodeAfterNodeBirth(node)\{ //node is of type YARF.YARFNode

                                                ...

                                              \}}

\item{shared_scripts}{Custom Javascript code that are always in scope when running all your custom methods. 
The default is \code{NULL} for no shared scripts.}

\item{use_missing_data}{Use the "missing-incorporated-in-attributes" strategy to fit data with missingness. The 
default is \code{TRUE}.}

\item{serialize}{Should the YARF model be saved? The default is \code{FALSE} as this is costly in processing
time and memory. This can only be set to \code{TRUE} if \code{wait = TRUE}. If \code{TRUE},
we will automatically serialize after other operations that add data (such as the OOB evaluation).}

\item{seed}{Set a random seed for reproducibility.}

\item{calculate_oob_error}{Should we also calculate the OOB error? Default is \code{TRUE}. Automatically is turned off if
\code{wait} becomes \code{FALSE}.}

\item{oob_cost_calculation_script}{This parameter will determine the out-of-bag cost of the RF forest model. Default is \code{NULL}. If
                                            it is \code{NULL}, then the cost will be 1-R^2 for regression models and misclassification error for classification 
                                            models.

                                            If non-null, an optional custom Javascript function which calculates the cost of a prediction given the true
                                            value of the prediction (see below). If is likely similar to \code{cost_single_node_calc_script}. It
                                            is recommended to share code between them by writing a function included in the \code{shared_scripts} argument  
                                            which can be referenced when calculating OOB results.

                                              function oobCost(y_hat, y)\{ //y_hat is the predicted value and y is the true value (both are of type double)

                                                ...

                                                return double //where a larger number indicates a higher cost to the error between y and y_hat.

                                              \}

                                            If this script is specified (i.e. the argument is non-\code{NULL}), this will also affect the output of the 
                                            \code{\link{YARF_update_with_oob_results}} function. This script can be reset after the model is built if necessary.}

\item{verbose}{Should we print out messages verbosely during construction? Default is \code{FALSE}.}

\item{debug_log}{Should we print out messages from Java? Default is \code{FALSE}.}
}
\value{
A list that (a) reiterates all ob the above arguments passed in and (b) \code{pred_type} is the 
											guess as to modeling type: regression or classification (c) \code{java_YARF} is the Java object
											(d) \code{y_levels} is the unique values of the response variable (e) \code{model_matrix_training_data}
											is the data matrix with factor variables converted to dummies that is fed into YARF as the X variables
											(f) \code{training_data_features} is the names of the features (g) \code{predictors_which_are_factors}
											is a list of the variables that are factors and (h) \code{n} and \code{p} which are the dimensions of
											the training data model matrix and (i) various other convenient data and internal data of use to 
											other functions in this package.
}
\description{
A convenience method to build a stump of a tree model via YARF. There are many customizations available.
}
\author{
Adam Kapelner
}
