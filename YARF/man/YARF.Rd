% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/YARF.R, R/YARF_builders.R
\docType{package}
\name{YARF}
\alias{YARF}
\alias{YARF-package}
\alias{YARF}
\title{A fully customizable Random Forests implementation}
\usage{
YARF(X = NULL, y = NULL, Xy = NULL, Xother = NULL,
  allow_missingness_in_y = FALSE, num_trees = NULL,
  bootstrap_indices = NULL, n_max_per_tree = NULL, other_indices = NULL,
  mtry = NULL, nodesize = NULL, mtry_script = NULL,
  split_vals_script = NULL, make_node_to_leaf_script = NULL,
  cost_single_node_calc_script = NULL, node_assign_script = NULL,
  after_node_birth_function_script = NULL, shared_scripts = NULL,
  use_missing_data = TRUE, use_missing_data_dummies_as_vars = TRUE,
  replace_missing_data_with_x_j_bar = FALSE, serialize = FALSE,
  seed = NULL, wait = TRUE, calculate_oob_error = TRUE,
  fit_until_convergence = FALSE, oob_cost_calculation_script = NULL,
  tolerance = 0.01, verbose = TRUE, debug_log = FALSE)
}
\arguments{
\item{X}{The data frame of training data}

\item{y}{The vector of training responses}

\item{Xy}{The data frame of training data where the last column is responses}

\item{Xother}{Other data that is used in the training but the RF doesn't split on it}

\item{allow_missingness_in_y}{If \code{TRUE}, missingness in the response variable, \code{y}, is allowed. If this is not
handled in the custom functions, YARF will crash. Default is \code{FALSE}.}

\item{num_trees}{The number of trees in the RF. Default is \code{NULL} which sets the value to \code{500} 
if \code{fit_until_convergence} is set to \code{FALSE} and 10,000 if \code{fit_until_convergence} 
is set to \code{TRUE}.

If the model is fit asynchronously via the \code{wait} parameter
being set to \code{TRUE}, this number represents a vague contract between the user and the 
software as the model fitting can be (a) halted by the user or the model can be (b) set 
to converge automatically (by setting the \code{fit_until_convergence} parameter
to \code{TRUE}). In the latter case, this parameter functions as the maximum number of trees
that can be created and thus, it is recommended that this number is very large, hence the default
of 10,000.}

\item{bootstrap_indices}{A list with keys 1, 2, ..., num_trees where each value is the indices of the training data
you wish to use for each tree. The default is \code{NULL} indicating the default algorithm 
of sampling {1,...,n} with replacement (i.e. the non-parametric bootsrap default). Needless
to say indices specified here will not be part of the out-of-bag collection of indices.    You may
specify more than enough (i.e. more than \code{num_trees}) elements in this list. Only the first
\code{num_trees} will be used. No warning message will be displayed if you include too many. If 
this parameter is specified, there is no need to specify \code{n_max_per_tree}.}

\item{n_max_per_tree}{An upper limit on the number of observations used to build each tree. If this parameter is specified,
there is no need to specify \code{bootstrap_indices}. Default is \code{NULL} for the entire dataset, \code{n}.}

\item{other_indices}{An optional list with keys 1,2,..., num_trees where each value is indices of the training data
you wish to use in some custom way for each tree using a custom function. If not custom function
is specified which makes use of this, it will be ignored. However, indices specified here will not be part of 
the out-of-bag collection of indices. If this is not your wish, the elements in the vectors
specified in this list's values should be a subset of those in the values of \code{bootstrap_indices}.
The default is \code{NULL} indicating you do not wish to specify any "other" data records.}

\item{mtry}{The number of variables tried at every split. The default is \code{NULL} which indicates
the out-of-box RF default which is floor(p / 3) for regression and floor(sqrt(p)) for
classification. If you want to use all possible features, set this parameter to "all".
If you want a custom function, leave this NULL and see next parameter.}

\item{nodesize}{The minimum number of observations in a node. YARF will stop splitting at this point.
If \code{NULL} the out-of-the-box default of 5 for regression and 1 for classification 
will be used.}

\item{mtry_script}{A custom javascript function which selects the variables to be greedily searched (see below)
                                            The default is \code{NULL} which employs the \code{mtry} argument. If you specify your function
                                            please randomize the order of the returned attributes to arbitrate ties.

                                              function tryVars(node)\{ //node is of type YARF.YARFNode

                                                ...

                                                return int_array //a subset of {0,...,p-1}, indices indicating the variables to perform the exhaustive search on

                                              \}}

\item{split_vals_script}{A custom javascript function which selects the split values to be greedily searched in feature j.
                                            The default is \code{NULL} which employs the midpoints of all sorted values.

                                              function tryVals(node, j)\{ //node is of type YARF.YARFNode and j is the feature number in {0,...,p-1}

                                                ...

                                                return double_array //a vector of split vals to greedily assess

                                              \}}

\item{make_node_to_leaf_script}{A custom javascript function to be used to calculate nodesize (see below).
                                            The default is \code{NULL} where nodesize will be calculated as a static constant (see the 
                                            \code{nodesize} argument).

                                              function makeNodeIntoLeaf(node)\{ //node is of type YARF.YARFNode

                                                ...

                                                return boolean //where true makes this node into a leaf

                                              \}}

\item{cost_single_node_calc_script}{A custom cost calculation for a potential node (when considering a split) in Javascript (see below). 
                                            The default is \code{NULL} which means the out-of-the-box default of sum of squared error relative
                                            to the sample average (if regression) and sum of entropy (if classification). You may find it 
                                            convenient to also made a node assignment here. If so, make sure you specify the node assignment
                                            function as a blank function (not \code{NULL}).

                                              function nodeCost(node)\{ //node is of type YARF.YARFNode

                                                ...

                                                return double //where a higher number indicates a higher cost

                                              \}}

\item{node_assign_script}{A custom node assignment function in Javascript (see below). This function is run after RF greedily finds the 
                                            "lowest cost" split. The default is \code{NULL} corresponding to the sample average of the node responses 
                                            in regression or the modal class during classification. 

                                              function assignYhatToNode(node)\{ //node is of type YARF.YARFNode

                                                ...

                                                return double //assigned as this node's predicted value ("y_hat")

                                              \}}

\item{after_node_birth_function_script}{A custom function in Javascript which is executed after a node is given birth to. The default is 
                                            \code{NULL} which implies nothing special is done, the Random Forest default. This is particularly
                                            useful to record extra information in the node (e.g. by writing a hash to the \code{other_info} 
                                            field in the node).

                                              function nodeAfterNodeBirth(node)\{ //node is of type YARF.YARFNode

                                                ...

                                              \}}

\item{shared_scripts}{Custom Javascript code that are always in scope when running all your custom methods. 
The default is \code{NULL} for no shared scripts.}

\item{use_missing_data}{Use the "missing-incorporated-in-attributes" strategy to fit data with missingness. The 
default is \code{TRUE}.}

\item{use_missing_data_dummies_as_vars}{For each predictor in the dataset that is missing, create a new variable \code{M_<name>} that
is one for observations that are missing and 0 if not. The default is \code{TRUE}.}

\item{serialize}{Should the YARF model be saved? The default is \code{FALSE} as this is costly in processing 
time and memory. This can only be set to \code{TRUE} if \code{wait = TRUE}. If \code{TRUE},
we will automatically serialize after other operations that add data (such as the OOB evaluation).}

\item{seed}{Set a random seed for reproducibility.}

\item{wait}{Should we hang R to wait for the YARF model to complete? The default is \code{TRUE}.}

\item{calculate_oob_error}{Should we also calculate the OOB error? Default is \code{TRUE}. Automatically is turned off if
\code{wait} becomes \code{FALSE}.}

\item{fit_until_convergence}{Default is \code{FALSE}. If \code{TRUE}, then the \code{wait} parameter is set to \code{FALSE}
                                            regardless of the user-specified value. Then, the Random Forest model is fit until "convergence"
                                            as defined below:  

                                            After each tree is completed, the OOB cost is computed. If the cost
                                            decreases the algorithm does not engage. However, upon the first 
                                            increase in cost, the model checks for convergence by calculating the average change in cost
                                            and the standard deviation of change in cost. If a 95\% confidence interval of the average cost is
                                            within the window created by plus or minus \code{tolerance} (i.e. from zero), then the algorithm has "converged".
                                            Upon convergence, the model is stopped and a message is printed to the console. Note that specification 
                                            of the \code{oob_cost_calculation_script} and a proper \code{tolerance} level is essential.

                                            It is strongly recommended to set the \code{num_trees} parameter large, otherwise the model can halt before
                                            it has converged since \code{num_trees} represents an upper limit. If left unspecified, \code{num_trees}
                                            is set to 10,000 when \code{fit_until_convergence} set to \code{TRUE}.

                                            If the user wishes to view the convergence in real time, we recommend the \code{\link{YARF_progress_reports}} 
                                            function. However, this function will lock the console.}

\item{oob_cost_calculation_script}{This parameter will determine the out-of-bag cost of the RF forest model. Default is \code{NULL}. If
                                            it is \code{NULL}, then the cost will be 1-R^2 for regression models and misclassification error for classification 
                                            models.

                                            If non-null, an optional custom Javascript function which calculates the cost of a prediction given the true
                                            value of the prediction (see below). If is likely similar to \code{cost_single_node_calc_script}. It
                                            is recommended to share code between them by writing a function included in the \code{shared_scripts} argument  
                                            which can be referenced when calculating OOB results.

                                              function oobCost(y_hat, y)\{ //y_hat is the predicted value and y is the true value (both are of type double)

                                                ...

                                                return double //where a larger number indicates a higher cost to the error between y and y_hat.

                                              \}

                                            If this script is specified (i.e. the argument is non-\code{NULL}), this will also affect the output of the 
                                            \code{\link{YARF_update_with_oob_results}} function. This script can be reset after the model is built if necessary.}

\item{tolerance}{This parameter is ignored unless \code{fit_until_convergence} is set to \code{TRUE}. If so, this controls the tolerance
used when assessing the convergence of the RF model. Default is \code{0.1}. If \code{oob_cost_calculation_script} is 
specified, this should also be specified as 0.1 may not be appropriate for a custom oob cost function.}

\item{verbose}{Should we print out messages verbosely during construction? Default is \code{FALSE}.}

\item{debug_log}{Should we print out messages from Java? Default is \code{FALSE}.}

\item{cost_both_children_calc_script}{A custom cost calculation in Javascript for an entire split considering both the putative left and right children
                                            nodes (see below). The default is \code{NULL} which means the out-of-the-box default for Random Forests which is
                                            sum of left and right nodes' costs for regression and average of left and right nodes' cost (relative
                                            to the number of observations in each node).

                                              function totalChildrenCost(leftNode, rightNode)\{ //both nodes are of type YARF.YARFNode

                                                ...

                                                return double //where a higher number indicates a higher cost

                                              \}}
}
\value{
A list that (a) reiterates all ob the above arguments passed in and (b) \code{pred_type} is the 
											guess as to modeling type: regression or classification (c) \code{java_YARF} is the Java object
											(d) \code{y_levels} is the unique values of the response variable (e) \code{model_matrix_training_data}
											is the data matrix with factor variables converted to dummies that is fed into YARF as the X variables
											(f) \code{training_data_features} is the names of the features (g) \code{predictors_which_are_factors}
											is a list of the variables that are factors and (h) \code{n} and \code{p} which are the dimensions of
											the training data model matrix and (i) various other convenient data and internal data of use to 
											other functions in this package.
}
\description{
Random Forests with (1) the ability to customize almost every algorithmic decions (2)
parallelization with asynchronicity (3) missingness incorporated in attributes and (4)
variable importance, interaction detection, variable(s) testing, tree illustrations et al.

Builds a YARF Model. There are many customizations available.
}
\references{
TK
}
\author{
Adam Kapelner \email{kapelner@qc.cuny.edu}

Adam Kapelner
}
\keyword{Learning,}
\keyword{Machine}
\keyword{Non-parametric}
\keyword{Tree-based}
\keyword{regression}
