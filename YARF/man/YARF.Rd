% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/YARF.R, R/YARF_builders.R
\docType{package}
\name{YARF}
\alias{YARF}
\alias{YARF-package}
\alias{YARF}
\title{A fully customizable Random Forests implementation}
\usage{
YARF(X = NULL, y = NULL, Xy = NULL, Xother = NULL,
  allow_missingness_in_y = FALSE, num_trees = 500,
  bootstrap_indices = NULL, other_indices = NULL, mtry = NULL,
  nodesize = NULL, mtry_script = NULL, split_vals_script = NULL,
  make_node_to_leaf_script = NULL, cost_single_node_calc_script = NULL,
  node_assign_script = NULL, after_node_birth_function_script = NULL,
  shared_scripts = NULL, use_missing_data = TRUE,
  use_missing_data_dummies_as_vars = TRUE,
  replace_missing_data_with_x_j_bar = FALSE, serialize = FALSE,
  seed = NULL, wait = TRUE, verbose = TRUE, debug_log = FALSE)
}
\arguments{
\item{X}{The data frame of training data}

\item{y}{The vector of training responses}

\item{Xy}{The data frame of training data where the last column is responses}

\item{Xother}{Other data that is used in the training but the RF doesn't split on it}

\item{allow_missingness_in_y}{If \code{TRUE}, missingness in the response variable, \code{y}, is allowed. If this is not
handled in the custom functions, YARF will crash. Default is \code{FALSE}.}

\item{num_trees}{The # of trees in the RF. Default is \code{500}.}

\item{bootstrap_indices}{A list with keys 1, 2, ..., num_trees where each value is the indices of the training data
you wish to use for each tree. The default is \code{NULL} indicating the default algorithm 
of sampling {1,...,n} with replacement (i.e. the non-parametric bootsrap default). Needless
to say indices specified here will not be part of the out-of-bag collection of indices.}

\item{other_indices}{An optional list with keys 1,2,..., num_trees where each value is indices of the training data
you wish to use in some custom way for each tree using a custom function. If not custom function
is specified which makes use of this, it will be ignored. However, indices specified here will not be part of 
the out-of-bag collection of indices. If this is not your wish, the elements in the vectors
specified in this list's values should be a subset of those in the values of \code{bootstrap_indices}.
The default is \code{NULL} indicating you do not wish to specify any "other" data records.}

\item{mtry}{The number of variables tried at every split. The default is \code{NULL} which indicates
the out-of-box RF default which is floor(p / 3) for regression and floor(sqrt(p)) for
classification. If you want a custom function, leave this NULL and see next parameter.}

\item{nodesize}{The minimum number of observations in a node. YARF will stop splitting at this point.
If \code{NULL} the out-of-the-box default of 5 for regression and 1 for classification 
will be used.}

\item{mtry_script}{A custom javascript function which selects the variables to be greedily searched (see below)
                                            The default is \code{NULL} which employs the \code{mtry} argument.

                                              function tryVars(node)\{ //node is of type YARF.YARFNode

                                                ...

                                                return int_array //a subset of {0,...,p-1}, indices indicating the variables to perform the exhaustive search on

                                              \}}

\item{split_vals_script}{A custom javascript function which selects the split values to be greedily searched in feature j.
                                            The default is \code{NULL} which employs the midpoints of all sorted values.

                                              function tryVals(node, j)\{ //node is of type YARF.YARFNode and j is the feature number in {0,...,p-1}

                                                ...

                                                return double_array //a vector of split vals to greedily assess

                                              \}}

\item{make_node_to_leaf_script}{A custom javascript function to be used to calculate nodesize (see below).
                                            The default is \code{NULL} where nodesize will be calculated as a static constant (see the 
                                            \code{nodesize} argument).

                                              function makeNodeIntoLeaf(node)\{ //node is of type YARF.YARFNode

                                                ...

                                                return boolean //where true makes this node into a leaf

                                              \}}

\item{cost_single_node_calc_script}{A custom cost calculation for a potential node (when considering a split) in Javascript (see below). 
                                            The default is \code{NULL} which means the out-of-the-box default of sum of squared error relative
                                            to the sample average (if regression) and sum of entropy (if classification). You may find it 
                                            convenient to also made a node assignment here. If so, make sure you specify the node assignment
                                            function as a blank function (not \code{NULL}).

                                              function nodeCost(node)\{ //node is of type YARF.YARFNode

                                                ...

                                                return double //where a higher number indicates a higher cost

                                              \}}

\item{node_assign_script}{A custom node assignment function in Javascript (see below). This function is run after RF greedily finds the 
                                            "lowest cost" split. The default is \code{NULL} corresponding to the sample average of the node responses 
                                            in regression or the modal class during classification. 

                                              function assignYhatToNode(node)\{ //node is of type YARF.YARFNode

                                                ...

                                                return double //assigned as this node's predicted value ("y_hat")

                                              \}}

\item{after_node_birth_function_script}{A custom function in Javascript which is executed after a node is given birth to. The default is 
                                            \code{NULL} which implies nothing special is done, the Random Forest default. This is particularly
                                            useful to record extra information in the node (e.g. by writing a hash to the \code{other_info} 
                                            field in the node).

                                              function nodeAfterNodeBirth(node)\{ //node is of type YARF.YARFNode

                                                ...

                                              \}}

\item{shared_scripts}{Custom Javascript code that are always in scope when running all your custom methods. 
The default is \code{NULL} for no shared scripts.}

\item{use_missing_data}{Use the "missing-incorporated-in-attributes" strategy to fit data with missingness. The 
default is \code{TRUE}.}

\item{use_missing_data_dummies_as_vars}{For each predictor in the dataset that is missing, create a new variable \code{M_<name>} that
is one for observations that are missing and 0 if not. The default is \code{TRUE}.}

\item{serialize}{Should the YARF model be saved? The default is \code{FALSE} as this is costly in processing 
time and memory. This can only be set to \code{TRUE} if \code{wait = TRUE}. If \code{TRUE},
we will automatically serialize after other operations that add data (such as the OOB evaluation).}

\item{seed}{Set a random seed for reproducibility.}

\item{wait}{Should we hang R to wait for the YARF model to complete? The default is \code{TRUE}.}

\item{verbose}{Should we print out messages verbosely during construction? Default is \code{FALSE}.}

\item{debug_log}{Should we print out messages from Java? Default is \code{FALSE}.}

\item{cost_both_children_calc_script}{A custom cost calculation in Javascript for an entire split considering both the putative left and right children
                                            nodes (see below). The default is \code{NULL} which means the out-of-the-box default for Random Forests which is
                                            sum of left and right nodes' costs for regression and average of left and right nodes' cost (relative
                                            to the number of observations in each node).

                                              function totalChildrenCost(leftNode, rightNode)\{ //both nodes are of type YARF.YARFNode

                                                ...

                                                return double //where a higher number indicates a higher cost

                                              \}}
}
\value{
A list that (a) reiterates all ob the above arguments passed in and (b) \code{pred_type} is the 
											guess as to modeling type: regression or classification (c) \code{java_YARF} is the Java object
											(d) \code{y_levels} is the unique values of the response variable (e) \code{model_matrix_training_data}
											is the data matrix with factor variables converted to dummies that is fed into YARF as the X variables
											(f) \code{training_data_features} is the names of the features (g) \code{predictors_which_are_factors}
											is a list of the variables that are factors and (h) \code{n} and \code{p} which are the dimensions of
											the training data model matrix and (i) various other convenient data and internal data of use to 
											other functions in this package.
}
\description{
Random Forests with (1) the ability to customize almost every algorithmic decions (2)
parallelization with asynchronicity (3) missingness incorporated in attributes and (4)
variable importance, interaction detection, variable(s) testing, tree illustrations et al.

Builds a YARF Model. There are many customizations available.
}
\references{
TK
}
\author{
Adam Kapelner \email{kapelner@qc.cuny.edu}

Adam Kapelner
}
\keyword{Learning,}
\keyword{Machine}
\keyword{Non-parametric}
\keyword{Tree-based}
\keyword{regression}
